<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nominated</title>
  <style>
  :root{ --muted:#9ca3af; --accent:#f3f4f6; --card-shadow: 0 8px 24px rgba(0,0,0,0.6); --background:#0b0b0d; --card-bg:#0f1724; }
  body { font-family: system-ui, -apple-system, Roboto, Arial; padding: 2rem; background:var(--background); color:var(--accent) }
    .container { max-width: 1000px; margin: 0 auto; }
    .top { display:flex; justify-content:space-between; align-items:center }
    button { padding:0.45rem 0.85rem; border-radius:6px; border:1px solid #e5e7eb; background:#fff; cursor:pointer }
    .msg { margin-top:1rem; padding:0.6rem; border-radius:6px; }
    .msg.ok { background:#e6ffed; color:#064e3b; }
    .msg.err { background:#fff1f2; color:#881337; }

  /* grid of nominated cards */
  .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:2rem; margin-top:1rem }
  .card { background:var(--card-bg); border-radius:12px; padding:0.9rem; box-shadow: var(--card-shadow); display:flex; flex-direction:column; gap:0.6rem; transition: transform .12s ease; color:var(--accent); margin-bottom: 20px; }
    .card:hover { transform: translateY(-4px) }
    .card .title { font-weight:600 }
    .card .meta { color:var(--muted); font-size:0.9rem }
    .card .actions { margin-top:auto; display:flex; gap:0.5rem; justify-content:flex-end }
  .btn-primary { background:#f59e0b; color:#0f1724; border:none; padding:0.45rem 0.7rem; border-radius:8px; cursor:pointer }
  .btn-primary:hover { background:#d97706 }
  /* selected / voted button */
  .btn-selected { background:#fb923c; color:#0f1724; border:none; padding:0.45rem 0.7rem; border-radius:8px; cursor:default }
  .btn-selected[disabled] { opacity:0.95 }
  .btn-selected:hover { background:#f97316 }
    .btn-ghost { background:transparent; border:1px solid #e5e7eb; padding:0.35rem 0.6rem; border-radius:8px }
  </style>
</head>
<body>
  <div class="container">
    <div class="top">
      <h1 id="title">Nominated</h1>
      <div>
        <button id="btnBack">Back</button>
        <button id="btnLogout">Logout</button>
      </div>
    </div>
    <p id="msg">Loading...</p>
    <div id="list"></div>
  </div>

  {{ template "auth_modal" . }}

  <script>
    const el = id => document.getElementById(id);
    const params = new URLSearchParams(window.location.search);
    const categoryId = params.get('category_id');
    if (!categoryId) {
      el('msg').textContent = 'category_id missing in query';
      throw new Error('category_id missing');
    }

    // use cookie-based auth; call /logout to clear cookie
    el('btnBack').addEventListener('click', () => window.history.back());
    el('btnLogout').addEventListener('click', async () => { await fetch('/logout', { method: 'GET', credentials: 'same-origin' }); window.location.href = '/login/new'; });

    // wiring to embedded auth modal
    let pendingVote = null;
    let pendingBtn = null;
    // mark modal as embedded so partial will dispatch events instead of redirecting
    window.AUTH_MODAL_EMBEDDED = true;
    document.addEventListener('auth:login', () => {
      // retry pending vote after successful auth
      if (pendingVote && pendingBtn) {
        // small delay to allow cookies to be set
        setTimeout(() => vote(pendingVote, pendingBtn), 250);
      }
    });

    async function fetchNominateds() {
      try {
        // fetch nominateds and current user votes so we can mark the selected one
        const [res, votesRes] = await Promise.all([
          fetch('/nominateds', { credentials: 'same-origin' }),
          fetch('/votes', { credentials: 'same-origin' }).catch(() => ({ ok: false }))
        ]);
        if (!res.ok) { el('msg').textContent = 'Failed to load nominateds: ' + await res.text(); return; }
        const data = await res.json();
        let votes = [];
        if (votesRes && votesRes.ok) {
          try { votes = await votesRes.json(); } catch(e) { votes = []; }
        }
        // map category -> nominated_id for this user
        const votedMap = {};
        if (Array.isArray(votes)) {
          votes.forEach(v => { votedMap[String(v.category_id)] = v.nominated_id });
        }
        const filtered = data.filter(n => String(n.category_id) === String(categoryId));
        el('msg').textContent = '';
        const list = el('list');
        list.innerHTML = '';
        if (!Array.isArray(filtered) || filtered.length === 0) { list.textContent = 'No nominations for this category.'; return; }
        // render as cards
        filtered.forEach(n => {
          const d = document.createElement('div');
          d.className = 'card';
          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = n.name;
          d.appendChild(title);
          const meta = document.createElement('div');
          meta.className = 'meta';
          // prefer the returned movie name (movie_name); fall back to id if not present
          meta.textContent = 'From: ' + (n.movie_name || n.movie_id);
          d.appendChild(meta);
          const actions = document.createElement('div');
          actions.className = 'actions';
          const btn = document.createElement('button');
          // if user already voted in this category, mark the nominated choice
          if (String(votedMap[String(categoryId)]) === String(n.id)) {
            btn.textContent = 'Voted';
            // show orange selected state for already-voted choice
            btn.className = 'btn-selected';
            btn.disabled = true;
          } else {
            btn.textContent = 'Vote';
            btn.className = 'btn-primary';
          }
          btn.addEventListener('click', () => vote(n.id, btn));
          actions.appendChild(btn);
          d.appendChild(actions);
          list.appendChild(d);
        });
      } catch (err) {
        el('msg').textContent = 'Error: ' + err.message;
      }
    }

    function getCookie(name) {
      const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
      return v ? v.pop() : '';
    }

    async function vote(nominatedId, btn) {
      // keep a reference in case we need to show login and retry
      pendingVote = nominatedId;
      pendingBtn = btn;
      btn.disabled = true;
      try {
        const csrf = getCookie('csrf_token');
        const res = await fetch('/add_vote', { method: 'POST', credentials: 'same-origin', headers: { 'Content-Type':'application/json', 'X-CSRF-Token': csrf }, body: JSON.stringify({ nominated_id: nominatedId }) });
        if (res.status === 201 || res.status === 200) {
          // success; reload the page so card states update and show the voted state
          // small delay for UX
          el('msg').innerHTML = '<div class="msg ok">Voted successfully</div>';
          setTimeout(() => window.location.reload(), 500);
          pendingVote = null; pendingBtn = null;
        } else if (res.status === 409) {
          const txt = await res.text();
          el('msg').innerHTML = '<div class="msg err">' + txt + '</div>';
          pendingVote = null; pendingBtn = null;
        } else if (res.status === 401) {
          // show embedded login modal and keep pending vote to retry after login
          pendingVote = nominatedId;
          pendingBtn = btn;
          try { window.authModal.setPendingButton(btn); } catch(e) {}
          try { window.authModal.show(); } catch(e) { window.AUTH_MODAL_EMBEDDED = false; window.location.href = '/login/new' }
        } else if (res.status === 403) {
          const txt = await res.text();
          el('msg').innerHTML = '<div class="msg err">CSRF error: ' + txt + '</div>';
          // maybe force user to login again
          pendingVote = nominatedId;
          pendingBtn = btn;
          try { window.authModal.setPendingButton(btn); } catch(e) {}
          try { window.authModal.show(); } catch(e) { window.AUTH_MODAL_EMBEDDED = false; window.location.href = '/login/new' }
        } else {
          const txt = await res.text();
          el('msg').innerHTML = '<div class="msg err">Failed to vote: ' + txt + '</div>';
          pendingVote = null; pendingBtn = null;
        }
      } catch (err) {
        el('msg').innerHTML = '<div class="msg err">Error: ' + err.message + '</div>';
        pendingVote = null; pendingBtn = null;
      } finally {
        if (!modal || modal.style.display === 'flex') {
          // leave button disabled while modal is open and pending
        } else {
          btn.disabled = false;
        }
      }
    }

    fetchNominateds();
  </script>
</body>
</html>
