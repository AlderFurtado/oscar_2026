<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nominated</title>
  <style>
  :root{
    --muted:#9ca3af;
    --accent:#f3f4f6;
    --yellow:#f59e0b; /* project yellow */
    --yellow-strong:#fb923c;
    --card-shadow: 0 12px 30px rgba(2,6,23,0.6);
    --background-1:#071121;
    --background-2:#0b1224;
    --card-bg: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  }

  @keyframes bgShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  body {
    font-family: Inter, system-ui, -apple-system, Roboto, Arial;
    padding: 2.5rem;
    margin: 0;
    color: var(--accent);
    background: linear-gradient(135deg, var(--background-1) 0%, var(--background-2) 50%, #081628 100%);
    background-size: 300% 300%;
    animation: bgShift 18s ease infinite;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .container { max-width: 1100px; margin: 0 auto; }
  .top { display:flex; justify-content:space-between; align-items:center; gap:1rem }
  h1 { margin:0; font-size:1.6rem; letter-spacing:0.6px }

  button {
    padding:0.5rem 0.9rem;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.06);
    background:transparent;
    color:var(--accent);
    cursor:pointer;
    transition: transform .15s ease, box-shadow .15s ease;
  }
  button:hover { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(2,6,23,0.45); }

  .msg { margin-top:1rem; padding:0.75rem; border-radius:10px; background: rgba(255,255,255,0.02); }
  .msg.ok { background: rgba(158,230,176,0.08); color:#9ee6b0 }
  .msg.err { background: rgba(255,20,60,0.06); color:#ffb4c6 }

  /* grid of nominated cards */
  .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:1.6rem; margin-top:1.4rem }
  .card {
    background: var(--card-bg);
    border-radius:14px;
    padding:1rem;
    box-shadow: var(--card-shadow);
    display:flex; flex-direction:column; gap:0.6rem;
    color:var(--accent);
    transform: translateY(0);
    transition: transform .28s cubic-bezier(.2,.9,.2,1), box-shadow .28s ease;
    border: 1px solid rgba(255,255,255,0.03);
  }
  .card:hover { transform: translateY(-8px) scale(1.01); box-shadow: 0 20px 40px rgba(2,6,23,0.7); }
  .card .title { font-weight:700; font-size:1.02rem }
  .card .meta { color:var(--muted); font-size:0.9rem }
  .card .actions { margin-top:auto; display:flex; gap:0.5rem; justify-content:flex-end }

  .btn-primary {
    background: linear-gradient(180deg, var(--yellow) 0%, var(--yellow-strong) 100%);
    color:#071021; border:none; padding:0.5rem 0.85rem; border-radius:10px; cursor:pointer;
    box-shadow: 0 8px 18px rgba(245,158,11,0.18);
  }
  .btn-primary:hover { transform: translateY(-3px) scale(1.02); }

  .btn-selected {
    background: linear-gradient(180deg, #ffd69a, var(--yellow-strong));
    color:#071021; border:none; padding:0.48rem 0.82rem; border-radius:10px; cursor:default;
  }
  .btn-selected[disabled] { opacity:0.98 }

  .btn-ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); padding:0.35rem 0.6rem; border-radius:8px }
  @media (max-width:520px) { body { padding:1rem } .grid { gap:1rem } }
  </style>
</head>
<body>
  <div class="container">
    <div class="top">
      <h1 id="title">Nominated</h1>
      <div>
        <button id="btnBack">Back</button>
        <button id="btnLogout" style="display:none">Logout</button>
      </div>
    </div>
    <p id="msg">Loading...</p>
    <div id="list"></div>
  </div>

  {{ template "auth_modal" . }}

  <script>
    const el = id => document.getElementById(id);
    const params = new URLSearchParams(window.location.search);
    const categoryId = params.get('category_id');
    if (!categoryId) {
      el('msg').textContent = 'category_id missing in query';
      throw new Error('category_id missing');
    }

    // fetch category metadata (name) and update title to show the category name
    (async function setCategoryTitle() {
      try {
        const res = await fetch('/categories?id=' + encodeURIComponent(categoryId), { credentials: 'same-origin' });
        if (!res.ok) return; // leave default title
        const c = await res.json();
        if (c && c.name) {
          el('title').textContent = c.name;
        }
      } catch (e) {
        // silent - keep default title
      }
    })();

    // check if user is authenticated; show logout button only when authenticated
    (async function checkAuthAndShowLogout() {
      try {
        const res = await fetch('/me', { credentials: 'same-origin' });
        if (res.ok) {
          // user is authenticated — show logout button
          const btn = el('btnLogout');
          if (btn) btn.style.display = '';
        }
      } catch (e) {
        // ignore network errors — leave logout hidden
      }
    })();

    // use cookie-based auth; call /logout to clear cookie
    el('btnBack').addEventListener('click', () => window.history.back());
    el('btnLogout').addEventListener('click', async () => { await fetch('/logout', { method: 'GET', credentials: 'same-origin' }); window.location.href = '/login/new'; });

    // wiring to embedded auth modal
    let pendingVote = null;
    let pendingBtn = null;
    // mark modal as embedded so partial will dispatch events instead of redirecting
    window.AUTH_MODAL_EMBEDDED = true;
    document.addEventListener('auth:login', () => {
      // retry pending vote after successful auth
      if (pendingVote && pendingBtn) {
        // small delay to allow cookies to be set
        setTimeout(() => vote(pendingVote, pendingBtn), 250);
      }
    });

    async function fetchNominateds() {
      try {
        // fetch nominateds and current user votes so we can mark the selected one
        const [res, votesRes] = await Promise.all([
          fetch('/nominateds', { credentials: 'same-origin' }),
          fetch('/votes', { credentials: 'same-origin' }).catch(() => ({ ok: false }))
        ]);
        if (!res.ok) { el('msg').textContent = 'Failed to load nominateds: ' + await res.text(); return; }
        const data = await res.json();
        let votes = [];
        if (votesRes && votesRes.ok) {
          try { votes = await votesRes.json(); } catch(e) { votes = []; }
        }
        // map category -> nominated_id for this user
        const votedMap = {};
        if (Array.isArray(votes)) {
          votes.forEach(v => { votedMap[String(v.category_id)] = v.nominated_id });
        }
        const filtered = data.filter(n => String(n.category_id) === String(categoryId));
        el('msg').textContent = '';
        const list = el('list');
        list.innerHTML = '';
        if (!Array.isArray(filtered) || filtered.length === 0) { list.textContent = 'No nominations for this category.'; return; }
        // render as cards
        filtered.forEach(n => {
          const d = document.createElement('div');
          d.className = 'card';
          const title = document.createElement('div');
          title.className = 'title';
          // show nominee name when present, otherwise fall back to the movie title
          title.textContent = n.name || n.movie_name;
          d.appendChild(title);
          const meta = document.createElement('div');
          meta.className = 'meta';
          // prefer the returned movie name (movie_name); fall back to id if not present
          meta.textContent = 'From: ' + (n.movie_name || n.movie_id);
          d.appendChild(meta);
          const actions = document.createElement('div');
          actions.className = 'actions';
          const btn = document.createElement('button');
          // if user already voted in this category, mark the nominated choice
          if (String(votedMap[String(categoryId)]) === String(n.id)) {
            btn.textContent = 'Voted';
            // show orange selected state for already-voted choice
            btn.className = 'btn-selected';
            btn.disabled = true;
          } else {
            btn.textContent = 'Vote';
            btn.className = 'btn-primary';
          }
          btn.addEventListener('click', () => vote(n.id, btn));
          actions.appendChild(btn);
          d.appendChild(actions);
          list.appendChild(d);
        });
      } catch (err) {
        el('msg').textContent = 'Error: ' + err.message;
      }
    }

    function getCookie(name) {
      const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
      return v ? v.pop() : '';
    }

    async function vote(nominatedId, btn) {
      // keep a reference in case we need to show login and retry
      pendingVote = nominatedId;
      pendingBtn = btn;
      btn.disabled = true;
      try {
        const csrf = getCookie('csrf_token');
        const res = await fetch('/add_vote', { method: 'POST', credentials: 'same-origin', headers: { 'Content-Type':'application/json', 'X-CSRF-Token': csrf }, body: JSON.stringify({ nominated_id: nominatedId }) });
        if (res.status === 201 || res.status === 200) {
          // success; reload the page so card states update and show the voted state
          // small delay for UX
          el('msg').innerHTML = '<div class="msg ok">Voted successfully</div>';
          setTimeout(() => window.location.reload(), 500);
          pendingVote = null; pendingBtn = null;
        } else if (res.status === 409) {
          const txt = await res.text();
          el('msg').innerHTML = '<div class="msg err">' + txt + '</div>';
          pendingVote = null; pendingBtn = null;
        } else if (res.status === 401) {
          // show embedded login modal and keep pending vote to retry after login
          pendingVote = nominatedId;
          pendingBtn = btn;
          try { window.authModal.setPendingButton(btn); } catch(e) {}
          try { window.authModal.show(); } catch(e) { window.AUTH_MODAL_EMBEDDED = false; window.location.href = '/login/new' }
        } else if (res.status === 403) {
          const txt = await res.text();
          el('msg').innerHTML = '<div class="msg err">CSRF error: ' + txt + '</div>';
          // maybe force user to login again
          pendingVote = nominatedId;
          pendingBtn = btn;
          try { window.authModal.setPendingButton(btn); } catch(e) {}
          try { window.authModal.show(); } catch(e) { window.AUTH_MODAL_EMBEDDED = false; window.location.href = '/login/new' }
        } else {
          const txt = await res.text();
          el('msg').innerHTML = '<div class="msg err">Failed to vote: ' + txt + '</div>';
          pendingVote = null; pendingBtn = null;
        }
      } catch (err) {
        el('msg').innerHTML = '<div class="msg err">Error: ' + err.message + '</div>';
        pendingVote = null; pendingBtn = null;
      } finally {
        if (!modal || modal.style.display === 'flex') {
          // leave button disabled while modal is open and pending
        } else {
          btn.disabled = false;
        }
      }
    }

    fetchNominateds();
  </script>
</body>
</html>
